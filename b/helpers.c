#include "helpers.h"

#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "b.tab.h"      /* generated by bison for the tokens */

struct node *finddecl(struct node *dlist, struct node *name)
{
    assert(name);
    struct listnode *curr = ASLIST(dlist);
    const char *namestr;

    if (name->type == N_NAME)
        namestr = ASNAME(name)->val;
    else if(name->type == N_VECELEM) {
        struct vecelemnode *v = (struct vecelemnode *)name;
        assert(v->vec->type == N_NAME);
        namestr = ASNAME(v->vec)->val;
    } else {
        assert(0);
    }

    while (curr) {
        if (curr->val->type == N_EXTERN) {
            if (!strcmp(ASEXTERN(curr->val)->val, namestr))
                return ASNODE(curr->val);
        } else if (curr->val->type == N_AUTO) {
            if (!strcmp(ASAUTO(curr->val)->val, namestr))
                return ASNODE(curr->val);
        } else {
            assert(0);
        }
        curr = curr->next;
    }

    return NULL;
}

int listlen(struct node *l)
{
    int len = 0;

    assert(l);
    assert(l->type == N_LIST);

    struct listnode *curr = ASLIST(l);

    while (curr) {
        ++len;
        curr = curr->next;
    }

    return len;
}

struct node *listback(struct node *l, struct node *n)
{
    if (!l)
        return mklist(n);

    assert(l->type == N_LIST);
    struct listnode *curr = ASLIST(l);

    while (curr->next) {
        curr = curr->next;
    }

    curr->next = (struct listnode*)mklist(n);
    return l;
}

struct node *listfront(struct node *l, struct node *n)
{
    if (!l)
        return mklist(n);

    assert(l->type == N_LIST);

    struct listnode *new = (struct listnode*)mklist(n);
    new->next = (struct listnode*)l;

    return (struct node*)new;
}

static void printlist(struct node *n, int indent)
{
    if (!n) {
        printf("<empty_list>\n");
        return;
    }

    assert(n->type == N_LIST);

    struct listnode *curr = (struct listnode*)n;

    printf("LIST(%d) begin: \n", n->id);
    while (curr) {
        print(curr->val, indent + 2);
        curr = curr->next;
    }
    printf("LIST(%d) end\n", n->id);
}

static void printfundef(struct node *f, int indent)
{
    assert(f->type == N_FUNDEF);

    printf("%*sFUNDEF(%d) begin:\n", indent+1, "", f->id);
    struct fundefnode *fun = (struct fundefnode*)f;
    printf("%*sNAME: ", indent+1, ""); 
    print(fun->name, indent + 2);
    printf("%*sARGS: ", indent+1, ""); 
    printlist(fun->args, indent + 2);
    printf("%*sDECLS: ", indent+1, ""); 
    printlist(fun->decls, indent + 2);
    printf("%*sBODY:", indent+1, ""); 
    printlist(fun->body, indent + 2);
    printf("%*sFUNDEF(%d) end\n", indent+1, "", f->id);
}

static void printcall(struct node *n, int indent)
{
    assert(n->type == N_CALL);

    struct fundefnode *f = (struct fundefnode*)n;

    printf("%*sCALL(%d):\n", indent, "", n->id);
    printf("%*sNAME: ", indent+1, ""); 
    print(f->name, indent + 2);
    printf("%*sARGS: ", indent+1, ""); 
    printlist(f->args, indent + 2);
}

static void printassign(struct node *n, int indent)
{
    const char *op;

    assert(n->type == N_ASSIGN);

    struct assignnode *a = (struct assignnode*)n;

    assert(a->left);
    assert(a->right);

    printf("%*sASSIGN(%d):\n", indent, "", a->id);

    switch (a->op) {
    case '=': op = "="; break;
    case ASEQU: op = "==="; break;
    case ASOREQU: op = "=|="; break;
    case ASLESSEQU: op = "=<="; break;
    case ASGREATEQU: op = "=>="; break;
    case ASSHL: op = "=<<"; break;
    case ASSHR: op = "=>>"; break;
    case ASOR: op = "=|"; break;
    case ASAND: op = "=&"; break;
    case ASLESS: op = "=<"; break;
    case ASGREAT: op = "=>"; break;
    case ASPLUS: op = "=+"; break;
    case ASMINUS: op = "=-"; break;
    case ASMOD: op = "=%"; break;
    case ASMUL: op = "=*"; break;
    case ASDIV: op = "=/"; break;
    default:
        assert(0);
    }

    printf("%*sOP: %s\n", indent, "", op);

    printf("%*sLEFT:\n", indent, "");
    print(a->left, indent + 2);
    printf("%*sRIGHT:\n", indent, "");
    print(a->right, indent + 2);
}

static void printbinary(struct node *n, int indent)
{
    assert(n->type == N_BINARY);

    struct binarynode *b = (struct binarynode*)n;

    printf("%*sBINARY(%d):\n", indent, "", b->id);

    if (b->op < 127) {
        printf("%*sOP: %c\n", indent, "", b->op);
    } else {
        const char *op = NULL;

        switch(b->op) {
        case LESSEQU : op = "<="; break;
        case GREATEQU : op = ">="; break;
        case EQU : op = "=="; break;
        case NOTEQU : op = "!="; break;
        case SHR : op = ">>"; break;
        case SHL : op = "<<"; break;
        default:
            assert(0);
        }

        printf("%*sOP: %s\n", indent, "", op);
    }

    printf("%*sLEFT:\n", indent, "");
    print(b->left, indent + 2);
    printf("%*sRIGHT:\n", indent, "");
    print(b->right, indent + 2);
}

static void printreturn(struct node *n, int indent)
{
    assert(n->type == N_RETURN);

    struct returnnode *ret = (struct returnnode*)n;

    printf("%*sRETURN(%d)\n", indent, "", ret->id);
    if (ret->val)
        print(ret->val, indent);
}

static void printif(struct node *n, int indent)
{
    assert(n->type == N_IF);

    struct ifnode *iff = (struct ifnode*)n;

    assert(iff->cond);
    assert(iff->truee);

    printf("%*sIF(%d) begin:\n", indent, "", iff->id);
    printf("%*sCOND:\n", indent, "");
    print(iff->cond, indent + 2);
    printf("%*sTRUE:\n", indent, "");
    print(iff->truee, indent + 2);

    if (iff->falsee){
        printf("%*sFALSE:\n", indent, "");
        print(iff->falsee, indent + 2);
    }

    printf("%*sIF(%d) end\n", indent, "", iff->id);
}

static void printwhile(struct node *n, int indent)
{
    assert(n->type == N_WHILE);

    struct whilenode *w = (struct whilenode*)n;

    assert(w->cond);
    assert(w->body);

    printf("%*sWHILE(%d) begin:\n", indent, "", w->id);
    printf("%*sCOND:\n", indent, "");
    print(w->cond, indent + 2);
    printf("%*sBODY:\n", indent, "");
    print(w->body, indent + 2);

    printf("%*sWHILE(%d) end\n", indent, "", w->id);
}

static void printunary(struct node *n, int indent)
{
    assert(n->type == N_UNARY);

    struct unarynode *u = (struct unarynode*)n;

    printf("%*sUNARY(%d):\n", indent, "", u->id);
    if (u->op < 127) {
        printf("%*sOP: %c\n", indent, "", u->op);
    } else {
        const char *op = NULL;

        switch(u->op) {
        case INC : op = "++"; break;
        case DEC : op = "--"; break;
        default:
            assert(0);
        }

        printf("%*sOP: %s\n", indent, "", op);
    }
    printf("%*sPRE: %d\n", indent, "", u->pre);
    printf("%*sVAL:\n", indent, "");
    print(u->val, indent + 2);
}

void printvecelem(struct node *n, int indent)
{
    assert(n->type == N_VECELEM);

    struct vecelemnode *v = (struct vecelemnode*)n;

    printf("%*sVECELEM(%d):\n", indent, "", v->id);
    printf("%*sVEC: ", indent + 2, "");
    print(v->vec, indent + 2);
    printf("%*sINDEX: ", indent + 2, "");
    print(v->index, indent + 2);
}

void printvardef(struct node *n, int indent)
{
    assert(n->type == N_VARDEF);

    struct vardefnode *v = (struct vardefnode*)n;

    printf("%*sVARDEF(%d): `%s`", indent, "", v->id, ASNAME(v->name)->val);
    if (v->init) {
        printf("=");
        print(v->init, 0);
    }
    printf("\n");
}

void printvecdef(struct node *n, int indent)
{
    assert(n->type == N_VECDEF);

    struct vecdefnode *v = (struct vecdefnode*)n;

    printf("%*sVECDEF(%d): `%s`", indent, "", v->id, ASNAME(v->name)->val);
    printf("%*sCOUNT: ", indent + 2, "");
    print(v->count, indent + 2);
}

void printternary(struct node *n, int indent)
{
    assert(n->type == N_TERNARY);

    struct ternarynode *t = (struct ternarynode*)n;

    printf("%*sTERNARY(%d):\n", indent, "", t->id);
    printf("%*sCOND:\n", indent, "");
    print(t->cond, indent + 2);
    printf("%*sTRUE:\n", indent, "");
    print(t->truee, indent + 2);
    printf("%*sFALSE:\n", indent, "");
    print(t->falsee, indent + 2);
}

void printlabel(struct node *n, int indent)
{
    assert(n->type == N_LABEL);

    struct labelnode *l = (struct labelnode*)n;

    printf("%*sLABEL(%d) begin:\n", indent, "", l->id);
    printf("%*sNAME: `%s`\n", indent, "", l->name);
    printf("%*sSTATEMENTS:\n", indent, "");
    print(l->statement, indent + 2);
    printf("%*sLABEL(%d) end:\n", indent, "", l->id);
}

void printgoto(struct node *n, int indent)
{
    assert(n->type == N_GOTO);

    struct gotonode *g = (struct gotonode*)n;

    printf("%*sGOTO(%d) begin:\n", indent, "", g->id);
    printf("%*sLABEL:\n", indent, "");
    print(g->label, indent + 2);
}

void printswitch(struct node *n, int indent)
{
    assert(n->type == N_SWITCH);

    struct switchnode *s = (struct switchnode*)n;

    printf("%*sSWITCH(%d) begin:\n", indent, "", s->id);
    printf("%*sVAL:\n", indent, "");
    print(s->val, indent + 2);
    printf("%*sSTATEMENT:\n", indent, "");
    print(s->statement, indent + 2);
    printf("%*sSWITCH(%d) end:\n", indent, "", s->id);
}

void printcase(struct node *n, int indent)
{
    assert(n->type == N_CASE);

    struct casenode *c = (struct casenode*)n;

    printf("%*sCASE(%d) begin:\n", indent, "", c->id);
    printf("%*sCONST:\n", indent, "");
    print(c->constant, indent + 2);
    printf("%*sSTATEMENT:\n", indent, "");
    print(c->statement, indent + 2);
    printf("%*sCASE(%d) end:\n", indent, "", c->id);
}

void print(struct node *n, int indent)
{
    assert(n);
    switch(n->type) {
    case N_EMPTY:
        printf("%*sEMPTY(%d)\n", indent, "", n->id);
        break;

    case N_STRING:
        printf("%*sSTR(%d): `%s`\n", indent, "", n->id, ASSTR(n)->val);
        break;

    case N_INT:
        printf("%*sINT(%d): %llu\n", indent, "", n->id, ASINT(n)->val);
        break;

    case N_NAME:
        printf("%*sNAME(%d): `%s`\n", indent, "", n->id, ASNAME(n)->val);
        break;

    case N_EXTERN:
        printf("%*sEXTERN(%d): `%s`\n", indent, "", n->id, ASEXTERN(n)->val);
        break;

    case N_AUTO:
        printf("%*sAUTO(%d): `%s`", indent, "", n->id, ASAUTO(n)->val);
        if (ASAUTO(n)->init) {
            printf("=");
            print(ASAUTO(n)->init, 0);
        }
        printf("\n");
        break;

    case N_LIST:
        printlist(n, indent);
        break;

    case N_CALL:
        printcall(n, indent);
        break;

    case N_FUNDEF:
        printfundef(n, indent);
        break;

    case N_ASSIGN:
        printassign(n, indent);
        break;

    case N_BINARY:
        printbinary(n, indent);
        break;

    case N_RETURN:
        printreturn(n, indent);
        break;

    case N_IF:
        printif(n, indent);
        break;

    case N_WHILE:
        printwhile(n, indent);
        break;

    case N_UNARY:
        printunary(n, indent);
        break;

    case N_VECELEM:
        printvecelem(n, indent);
        break;

    case N_VARDEF:
        printvardef(n, indent);
        break;

    case N_VECDEF:
        printvecdef(n, indent);
        break;

    case N_TERNARY:
        printternary(n, indent);
        break;

    case N_LABEL:
        printlabel(n, indent);
        break;

    case N_GOTO:
        printgoto(n, indent);
        break;

    case N_SWITCH:
        printswitch(n, indent);
        break;

    case N_CASE:
        printcase(n, indent);
        break;

    default:
        assert(0);
    };
}
