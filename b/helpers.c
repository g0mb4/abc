#include "helpers.h"

#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "b.tab.h"      /* generated by bison for the tokens */

struct node *finddecl(struct node *dlist, struct node *name)
{
    assert(name);
    struct listnode *curr = ASLIST(dlist);

    assert(name->type == N_NAME);
    const char *namestr = ASNAME(name)->val;

    while (curr) {
        assert(curr->val->type == N_EXTERN || curr->val->type == N_AUTO);
        if (curr->val->type == N_EXTERN) {
            if (!strcmp(ASEXTERN(curr->val)->val, namestr))
                return ASNODE(curr->val);
        } else {
            if (!strcmp(ASAUTO(curr->val)->val, namestr))
                return ASNODE(curr->val);
        }
        curr = curr->next;
    }

    return NULL;
}

struct node *listback(struct node *l, struct node *n)
{
    if (!l)
        return mklist(n);

    assert(l->type == N_LIST);
    struct listnode *curr = (struct listnode*)l;

    while (curr->next) {
        curr = curr->next;
    }

    curr->next = (struct listnode*)mklist(n);
    return l;
}

struct node *listfront(struct node *l, struct node *n)
{
    if (!l)
        return mklist(n);

    assert(l->type == N_LIST);

    struct listnode *new = (struct listnode*)mklist(n);
    new->next = (struct listnode*)l;

    return (struct node*)new;
}

static void printlist(struct node *n, int indent)
{
    if (!n) {
        printf("<empty_list>\n");
        return;
    }

    assert(n->type == N_LIST);

    struct listnode *curr = (struct listnode*)n;

    printf("LIST(%d) begin: \n", n->id);
    while (curr) {
        print(curr->val, indent + 2);
        curr = curr->next;
    }
    printf("LIST(%d) end\n", n->id);
}

static void printdef(struct node *f, int indent)
{
    assert(f);
    assert(f->type == N_DEF);

    printf("%*sDEF(%d) begin:\n", indent+1, "", f->id);
    struct defnode *func = (struct defnode*)f;
    printf("%*sNAME: ", indent+1, ""); 
    print(func->name, indent + 2);
    printf("%*sARGS: ", indent+1, ""); 
    printlist(func->args, indent + 2);
    printf("%*sDECLS: ", indent+1, ""); 
    printlist(func->decls, indent + 2);
    printf("%*sBODY:", indent+1, ""); 
    printlist(func->body, indent + 2);
    printf("%*sDEF(%d) end:\n", indent+1, "", f->id);
}

static void printcall(struct node *n, int indent)
{
    assert(n);
    assert(n->type == N_CALL);

    struct defnode *f = (struct defnode*)n;

    printf("%*sCALL(%d):\n", indent, "", n->id);
    printf("%*sNAME: ", indent+1, ""); 
    print(f->name, indent + 2);
    printf("%*sARGS: ", indent+1, ""); 
    printlist(f->args, indent + 2);
}

static void printassign(struct node *n, int indent)
{
    const char *op;

    assert(n);
    assert(n->type == N_ASSIGN);

    struct assignnode *a = (struct assignnode*)n;

    assert(a->left);
    assert(a->right);

    printf("%*sASSIGN(%d):\n", indent, "", a->id);

    switch (a->op) {
    case '=': op = "="; break;
    case ASEQU: op = "===" ; break;
    case ASOREQU: op = "=|=" ; break;
    case ASLESSEQU: op = "=<=" ; break;
    case ASGREATEQU: op = "=>=" ; break;
    case ASSHL: op = "=<<" ; break;
    case ASSHR: op = "=>>" ; break;
    case ASOR: op = "=|"  ; break;
    case ASAND: op = "=&"  ; break;
    case ASLESS: op = "=<"  ; break;
    case ASGREAT: op = "=>"  ; break;
    case ASPLUS: op = "=+"  ; break;
    case ASMINUS: op = "=-"  ; break;
    case ASMOD: op = "=%"  ; break;
    case ASMUL: op = "=*"  ; break;
    case ASDIV: op = "=/"  ; break;
    default:
        assert(0);
    }

    printf("%*sOP: %s\n", indent, "", op);

    printf("%*sLEFT:\n", indent, "");
    print(a->left, indent + 2);
    printf("%*sRIGHT:\n", indent, "");
    print(a->right, indent + 2);
}

static void printbinary(struct node *n, int indent)
{
    assert(n);
    assert(n->type == N_BINARY);

    struct binarynode *b = (struct binarynode*)n;

    printf("%*sBINARY(%d):\n", indent, "", b->id);

    if (b->op < 127) {
        printf("%*sOP: %c\n", indent, "", b->op);
    } else {
        const char *op = NULL;

        switch(b->op) {
        case LESSEQU : op = "<="; break;
        case GREATEQU : op = ">="; break;
        case EQU : op = "=="; break;
        case NOTEQU : op = "!="; break;
        case SHR : op = ">>"; break;
        case SHL : op = "<<"; break;
        default:
            assert(0);
        }

        printf("%*sOP: %s\n", indent, "", op);
    }

    printf("%*sLEFT:\n", indent, "");
    print(b->left, indent + 2);
    printf("%*sRIGHT:\n", indent, "");
    print(b->right, indent + 2);
}

static void printreturn(struct node *n, int indent)
{
    assert(n);
    assert(n->type == N_RETURN);

    struct returnnode *ret = (struct returnnode*)n;

    printf("%*sRETURN(%d)\n", indent, "", ret->id);
    if (ret->val)
        print(ret->val, indent);
}

static void printif(struct node *n, int indent)
{
    assert(n);
    assert(n->type == N_IF);

    struct ifnode *iff = (struct ifnode*)n;

    assert(iff->cond);
    assert(iff->truee);

    printf("%*sIF(%d) begin:\n", indent, "", iff->id);
    printf("%*sCOND:\n", indent, "");
    print(iff->cond, indent + 2);
    printf("%*sTRUE:\n", indent, "");
    print(iff->truee, indent + 2);

    if (iff->falsee){
        printf("%*sFALSE:\n", indent, "");
        print(iff->falsee, indent + 2);
    }

    printf("%*sIF(%d) end\n", indent, "", iff->id);
}

static void printwhile(struct node *n, int indent)
{
    assert(n);
    assert(n->type == N_WHILE);

    struct whilenode *w = (struct whilenode*)n;

    assert(w->cond);
    assert(w->body);

    printf("%*sWHILE(%d) begin:\n", indent, "", w->id);
    printf("%*sCOND:\n", indent, "");
    print(w->cond, indent + 2);
    printf("%*sBODY:\n", indent, "");
    print(w->body, indent + 2);

    printf("%*sWHILE(%d) end\n", indent, "", w->id);
}

static void printunary(struct node *n, int indent)
{
    assert(n);
    assert(n->type == N_UNARY);

    struct unarynode *u = (struct unarynode*)n;

    printf("%*sUNARY(%d):\n", indent, "", u->id);
    if (u->op < 127) {
        printf("%*sOP: %c\n", indent, "", u->op);
    } else {
        const char *op = NULL;

        switch(u->op) {
        case INC : op = "++"; break;
        case DEC : op = "--"; break;
        default:
            assert(0);
        }

        printf("%*sOP: %s\n", indent, "", op);
    }
    printf("%*sPRE: %d\n", indent, "", u->pre);
    printf("%*sVAL:\n", indent, "");
    print(u->val, indent + 2);
}

void print(struct node *n, int indent)
{
    assert(n);
    switch(n->type) {
    case N_EMPTY:
        printf("%*sEMPTY(%d)\n", indent, "", n->id);
        break;
    case N_STRING:
        printf("%*sSTR(%d): `%s`\n", indent, "", n->id, ASSTR(n)->val);
        break;
    case N_INT:
        printf("%*sINT(%d): %llu\n", indent, "", n->id, ASINT(n)->val);
        break;
    case N_NAME:
        printf("%*sNAME(%d): `%s`\n", indent, "", n->id, ASNAME(n)->val);
        break;
    case N_EXTERN:
        printf("%*sEXTERN(%d): `%s`\n", indent, "", n->id, ASEXTERN(n)->val);
        break;
    case N_AUTO:
        printf("%*sAUTO(%d): `%s`", indent, "", n->id, ASAUTO(n)->val);
        if (ASAUTO(n)->init) {
            printf("=");
            print(ASAUTO(n)->init, 0);
        }
        printf("\n");
        break;
    case N_LIST:
        printlist(n, indent);
        break;
    case N_CALL:
        printcall(n, indent);
        break;
    case N_DEF:
        printdef(n, indent);
        break;
    case N_ASSIGN:
        printassign(n, indent);
        break;
    case N_BINARY:
        printbinary(n, indent);
        break;
    case N_RETURN:
        printreturn(n, indent);
        break;
    case N_IF:
        printif(n, indent);
        break;
    case N_WHILE:
        printwhile(n, indent);
        break;
    case N_UNARY:
        printunary(n, indent);
        break;
    default:
        assert(0);
    };
}
