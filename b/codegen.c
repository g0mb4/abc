#include "codegen.h"
#include "helpers.h"

#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "b.tab.h"      /* generated by bison for the tokens */

extern FILE *out;    /* from main.c */

// TODO: dynarr
#define DATASIZE   1024
static const char *data[DATASIZE];
static int datactr;

static struct fundefnode *currdef = NULL;

static void gen(struct node *n);

static void appenddata(const char *s)
{
    int i;
    assert(s);

    for (i = 0; i < datactr; ++i) {
        if (!strcmp(data[i], s))
            return;
    }

    assert(datactr + 1 < DATASIZE);
    data[datactr++] = strdup(s);
}

static void appendstr(int id, const char *s)
{
    char buffer[128];

    memset(buffer, 0, sizeof(buffer));
    snprintf(buffer, sizeof(buffer), "str_%d: .asciz \"%s\"\n", id, s);
    appenddata(buffer);
}

static char *argreg(int index)
{
    switch(index) {
    case 0: return "%rdi";
    case 1: return "%rsi";
    case 2: return "%rdx";
    case 3: return "%rcx";
    case 4: return "%r8";
    case 5: return "%r9";
    default:
        assert(0);
    }
}

static void gendecl(void)
{
    struct autonode *a;

    assert(currdef);

    if (!currdef->decls)
        return;

    struct listnode *curr = ASLIST(currdef->decls);
    while (curr) {
        assert(curr->val->type == N_EXTERN || curr->val->type == N_AUTO);
        if (curr->val->type == N_AUTO) {
            a = ASAUTO(curr->val);
            currdef->stacksize += WORDSIZE;
            ASAUTO(curr->val)->offset = currdef->stacksize;   /* update the list element, not the copy */
            fprintf(out, "\tsubq $%lu, %%rsp\n", WORDSIZE);

            if (a->init) {
                if (a->init->type == N_INT) {
                    fprintf(out, "\tmovq $%llu, -%llu(%%rbp)\n", ASINT(a->init)->val, currdef->stacksize);
                } else if(a->init->type == N_STRING) {
                    fprintf(out, "\tmovq $str_%d, -%llu(%%rbp)\n", a->init->id, currdef->stacksize);
                    appendstr(a->init->id, ((struct strnode *)a->init)->val);
                } else {
                    assert(0);
                }
            } 
        }
        curr = curr->next;
    }
}

static void genargs(struct node *n)
{
    struct autonode *a;

    assert(currdef);

    if (!n)
        return;

    assert(n->type == N_LIST);
    struct listnode *curr = ASLIST(n);
    int i = 0;
    while (curr) {
        assert(curr->val->type == N_NAME);
        a = ASAUTO(mkauto(ASNAME(curr->val)->val));
        currdef->stacksize += WORDSIZE;
        a->offset = currdef->stacksize;
        fprintf(out, "\tsubq $%lu, %%rsp\n", WORDSIZE);
        fprintf(out, "\tmovq %s, -%llu(%%rbp)\n", argreg(i++), currdef->stacksize);

        currdef->decls = listback(currdef->decls, ASNODE(a));

        curr = curr->next;
    }
}

static void genfundef(struct node *n)
{
    assert(n->type == N_FUNDEF);

    struct fundefnode *def = (struct fundefnode*)n;

    currdef = def;

    assert(def->body);

    fprintf(out, "\t.global %s\n", ASSTR(def->name)->val);
    fprintf(out, "%s:\n", ASSTR(def->name)->val);

    // prolog
    fprintf(out, "\tpushq %%rbp\n");
    fprintf(out, "\tmovq %%rsp, %%rbp\n");

    gendecl();
    genargs(def->args);

    gen(def->body);

    // epilog
    fprintf(out, "end_%d:\n", currdef->id);
    fprintf(out, "\taddq $%llu, %%rsp\n", currdef->stacksize);

    fprintf(out, "\tpopq %%rbp\n");
    fprintf(out, "\tret\n");
    fprintf(out, "\n");

    currdef = NULL;
}

static void genlist(struct node *n)
{
    if (!n)
        return;

    assert(n->type == N_LIST);
    struct listnode *curr = (struct listnode*)n;
    while (curr) {
        gen(curr->val);
        curr = curr->next;
    }
}

static void genbinary(struct node *n)
{
    assert(n);
    assert(n->type == N_BINARY);

    struct binarynode *b = (struct binarynode*)n;

    gen(b->right);  // value in %rax
    fprintf(out, "\tpushq %%rax\n");
    gen(b->left);   // value in %rax
    fprintf(out, "\tpopq %%rbx\n");
   
    switch(b->op) {
    case '+':
        fprintf(out, "\taddq %%rbx, %%rax\n");
        break;
    case '-':
        fprintf(out, "\tsubq %%rbx, %%rax\n");
        break;
    case '*':
        fprintf(out, "\timulq %%rbx, %%rax\n");
        break;
    case '/':
        fprintf(out, "\tmovq $0, %%rdx\n");
        fprintf(out, "\tcqto\n");
        fprintf(out, "\tidivq %%rbx\n");
        break;
    case '%':
        fprintf(out, "\tmovq $0, %%rdx\n");
        fprintf(out, "\tcqto\n");
        fprintf(out, "\tidivq %%rbx\n");
        fprintf(out, "\tmovq %%rdx, %%rax\n");
        break;
     case '&':
        fprintf(out, "\tandq %%rbx, %%rax\n");
        break;
    case '|':
        fprintf(out, "\torq %%rbx, %%rax\n");
        break;
    case '<':
        fprintf(out, "\tcmp %%rbx, %%rax\n");
        fprintf(out, "\tjge ge_%d\n", n->id);
        fprintf(out, "\tmovq $1, %%rax\n");
        fprintf(out, "\tjmp end_%d\n", n->id);
        fprintf(out, "\tge_%d:\n", n->id);
        fprintf(out, "\tmovq $0, %%rax\n");
        fprintf(out, "\tend_%d:\n", n->id);
        break;
    case '>':
        fprintf(out, "\tcmp %%rbx, %%rax\n");
        fprintf(out, "\tjle le_%d\n", n->id);
        fprintf(out, "\tmovq $1, %%rax\n");
        fprintf(out, "\tjmp end_%d\n", n->id);
        fprintf(out, "\tle_%d:\n", n->id);
        fprintf(out, "\tmovq $0, %%rax\n");
        fprintf(out, "\tend_%d:\n", n->id);
        break;
    case LESSEQU:
        fprintf(out, "\tcmp %%rbx, %%rax\n");
        fprintf(out, "\tjle le_%d\n", n->id);
        fprintf(out, "\tmovq $0, %%rax\n");
        fprintf(out, "\tjmp end_%d\n", n->id);
        fprintf(out, "\tle_%d:\n", n->id);
        fprintf(out, "\tmovq $1, %%rax\n");
        fprintf(out, "\tend_%d:\n", n->id);
        break;
    case GREATEQU:
        fprintf(out, "\tcmp %%rbx, %%rax\n");
        fprintf(out, "\tjge ge_%d\n", n->id);
        fprintf(out, "\tmovq $0, %%rax\n");
        fprintf(out, "\tjmp end_%d\n", n->id);
        fprintf(out, "\tge_%d:\n", n->id);
        fprintf(out, "\tmovq $1, %%rax\n");
        fprintf(out, "\tend_%d:\n", n->id);
        break;
    case EQU:
        fprintf(out, "\tcmp %%rbx, %%rax\n");
        fprintf(out, "\tje e_%d\n", n->id);
        fprintf(out, "\tmovq $0, %%rax\n");
        fprintf(out, "\tjmp end_%d\n", n->id);
        fprintf(out, "\te_%d:\n", n->id);
        fprintf(out, "\tmovq $1, %%rax\n");
        fprintf(out, "\tend_%d:\n", n->id);
        break;
    case NOTEQU:
        fprintf(out, "\tcmp %%rbx, %%rax\n");
        fprintf(out, "\tjne ne_%d\n", n->id);
        fprintf(out, "\tmovq $0, %%rax\n");
        fprintf(out, "\tjmp end_%d\n", n->id);
        fprintf(out, "\tne_%d:\n", n->id);
        fprintf(out, "\tmovq $1, %%rax\n");
        fprintf(out, "\tend_%d:\n", n->id);
        break;
    case SHR:
        fprintf(out, "\tmovq %%rbx, %%rcx\n");
        fprintf(out, "\tsarq %%cl, %%rax\n");
        break;
    case SHL:
        fprintf(out, "\tmovq %%rbx, %%rcx\n");
        fprintf(out, "\tsalq %%cl, %%rax\n");
        break;
    default:
        assert(0);
    }
}

static void genunary(struct node *n)
{
    assert(n);
    assert(n->type == N_UNARY);

    struct unarynode *u = (struct unarynode*)n;
    struct node *var;

    switch(u->op) {
    case INC:
        assert(u->val->type == N_NAME);
        var = finddecl(currdef->decls, u->val);
        assert(var);

        if (u->pre) {
            if (var->type == N_AUTO) {
                fprintf(out, "\taddq $1, -%llu(%%rbp)\n", ASAUTO(var)->offset);
                fprintf(out, "\tmovq -%llu(%%rbp), %%rax\n", ASAUTO(var)->offset);
            } else if (var->type == N_EXTERN) {
                fprintf(out, "\taddq $1, %s\n", ASEXTERN(var)->val);
                fprintf(out, "\tmovq %s, %%rax\n", ASEXTERN(var)->val);
            } else {
                assert(0);
            }
        } else {
            if (var->type == N_AUTO) {
                fprintf(out, "\tmovq -%llu(%%rbp), %%rax\n", ASAUTO(var)->offset);
                fprintf(out, "\tleaq 1(%%rax), %%rbx\n");
                fprintf(out, "\tmovq %%rbx, -%llu(%%rbp)\n", ASAUTO(var)->offset);
            } else if (var->type == N_EXTERN) {
                fprintf(out, "\tmovq %s, %%rax\n", ASEXTERN(var)->val);
                fprintf(out, "\tleaq 1(%%rax), %%rbx\n");
                fprintf(out, "\tmovq %%rbx, %s\n", ASEXTERN(var)->val);
            } else {
                assert(0);
            }
        }

        break;
    case DEC:
        assert(u->val->type == N_NAME);
        var = finddecl(currdef->decls, u->val);
        assert(var);

        if (u->pre) {
            if (var->type == N_AUTO) {
                fprintf(out, "\tsubq $1, -%llu(%%rbp)\n", ASAUTO(var)->offset);
                fprintf(out, "\tmovq -%llu(%%rbp), %%rax\n", ASAUTO(var)->offset);
            } else if (var->type == N_EXTERN) {
                fprintf(out, "\tsubq $1, %s\n", ASEXTERN(var)->val);
                fprintf(out, "\tmovq %s, %%rax\n", ASEXTERN(var)->val);
            } else {
                assert(0);
            }
        } else {
            if (var->type == N_AUTO) {
                fprintf(out, "\tmovq -%llu(%%rbp), %%rax\n", ASAUTO(var)->offset);
                fprintf(out, "\tleaq -1(%%rax), %%rbx\n");
                fprintf(out, "\tmovq %%rbx, -%llu(%%rbp)\n", ASAUTO(var)->offset);
            } else if (var->type == N_EXTERN) {
                fprintf(out, "\tmovq %s, %%rax\n", ASEXTERN(var)->val);
                fprintf(out, "\tleaq -1(%%rax), %%rbx\n");
                fprintf(out, "\tmovq %%rbx, %s\n", ASEXTERN(var)->val);
            } else {
                assert(0);
            }
        }
        break;
    case '-':
        gen(u->val);
        fprintf(out, "\tnegq %%rax\n");
        break;
    case '!':
        gen(u->val);
        fprintf(out, "\tcmpq $0, %%rax\n");
        fprintf(out, "\tje zero_%d\n", u->id);
        fprintf(out, "\tmovq $0, %%rax\n");
        fprintf(out, "\tjmp end_%d\n", u->id);
        fprintf(out, "\tzero_%d:\n", u->id);
        fprintf(out, "\tmovq $1, %%rax\n");
        fprintf(out, "\tend_%d:\n", u->id);
        break;
    default:
        assert(0);
    }
}

static void gencall(struct node *n)
{
    int argindex; 
    assert(n);
    assert(n->type == N_CALL);

    struct callnode *call = (struct callnode*)n;

    if (call->args)
    {
        struct listnode *args = (struct listnode*)call->args;
        argindex = 0;
        while (args) {
            struct node *arg = args->val;

            gen(arg);
            fprintf(out, "\tmovq %%rax, %s\n", argreg(argindex));

            args = args->next;
            argindex++;
        }
    }

    fprintf(out, "\tcall %s\n", ((struct namenode *)call->name)->val);
}

static void genname(struct node *n)
{
    assert(n);
    assert(n->type == N_NAME);

    struct node *var = finddecl(currdef->decls, n);
    assert(var);

    assert(var->type == N_AUTO || var->type == N_EXTERN);
    gen(var);
}

static void genassign(struct node *n)
{
    assert(n);
    assert(n->type == N_ASSIGN);

    struct assignnode *a = (struct assignnode *)n;

    assert(a->left);
    assert(a->right);

    struct node *left = finddecl(currdef->decls, a->left);
    assert(left);

    switch (a->op) {
    case '=':
        gen(a->right);
        break;
    case ASEQU: assert(0 && "not implemented"); break;
    case ASOREQU: assert(0 && "not implemented"); break;
    case ASLESSEQU: assert(0 && "not implemented"); break;
    case ASGREATEQU: assert(0 && "not implemented"); break;
    case ASSHL: assert(0 && "not implemented"); break;
    case ASSHR: assert(0 && "not implemented"); break;
    case ASOR: assert(0 && "not implemented"); break;
    case ASAND: assert(0 && "not implemented"); break;
    case ASLESS: assert(0 && "not implemented"); break;
    case ASGREAT: assert(0 && "not implemented"); break;
    case ASPLUS:
        gen(mkbinary('+', a->left, a->right));
        break;
    case ASMINUS:
        gen(mkbinary('-', a->left, a->right));
        break;
    case ASMOD:
        gen(mkbinary('%', a->left, a->right));
        break;
    case ASMUL:
        gen(mkbinary('*', a->left, a->right));
        break;
    case ASDIV:
        gen(mkbinary('/', a->left, a->right));
        break;
    default:
        assert(0);
    }

    if (left->type == N_AUTO) {
        if (a->left->type == N_NAME)
            fprintf(out, "\tmovq %%rax, -%llu(%%rbp)\n", ASAUTO(left)->offset);
        else 
            assert(0);
    } else if (left->type == N_EXTERN) {
        if (a->left->type == N_NAME) {
            fprintf(out, "\tmovq %%rax, %s\n", ASEXTERN(left)->val);
        } else if (a->left->type == N_VECELEM) {
            struct vecelemnode *v = (struct vecelemnode*)a->left;
            fprintf(out, "\tpushq %%rax\n");
            gen(v->index);
            fprintf(out, "\tmovq %%rax, %%rbx\n");
            fprintf(out, "\tpopq %%rax\n");
            fprintf(out, "\tmovq %%rax, %s(,%%rbx, %lu)\n", ASEXTERN(left)->val, WORDSIZE);
        } else {
            assert(0);
        }
    } else {
        assert(0);
    }
}

static void genreturn(struct node *n)
{
    assert(n);
    assert(n->type == N_RETURN);

    assert(currdef);

    struct returnnode *ret = (struct returnnode *)n;

    if (ret->val)
        gen(ret->val);

    fprintf(out, "\tjmp end_%d\n", currdef->id);
}

static void genif(struct node *n)
{
    assert(n);
    assert(n->type == N_IF);

    struct ifnode *iff = (struct ifnode *)n;

    assert(iff->cond);
    assert(iff->truee);

    gen(iff->cond);
    fprintf(out, "\tcmpq $0, %%rax\n");
    if (iff->falsee) {
        fprintf(out, "\tje if_%d_false\n", iff->id);
        gen(iff->truee);
        fprintf(out, "\tjmp if_%d_end\n", iff->id);
        fprintf(out, "if_%d_false:\n", iff->id);
        gen(iff->falsee);
        fprintf(out, "if_%d_end:\n", iff->id);
    } else {
        fprintf(out, "\tje if_%d_end\n", iff->id);
        gen(iff->truee);
        fprintf(out, "if_%d_end:\n", iff->id);
    }
}

static void genwhile(struct node *n)
{
    assert(n);
    assert(n->type == N_WHILE);

    struct whilenode *w = (struct whilenode *)n;

    assert(w->cond);
    assert(w->body);

    fprintf(out, "while_%d_start:\n", w->id);
    gen(w->cond);
    fprintf(out, "\tcmpq $0, %%rax\n");
    fprintf(out, "\tje while_%d_end\n", w->id);
    gen(w->body);
    fprintf(out, "\tjmp while_%d_start\n", w->id);
    fprintf(out, "while_%d_end:\n", w->id);
}

static void genvecelem(struct node *n)
{
    assert(n);
    assert(n->type == N_VECELEM);

    struct vecelemnode *v = (struct vecelemnode *)n;

    struct node *vecdecl = finddecl(currdef->decls, n);
    assert(vecdecl);

    assert(vecdecl->type == N_EXTERN);

    gen(v->index);
    fprintf(out, "\tmovq %%rax, %%rbx\n");
    fprintf(out, "\tmovq %s(,%%rbx, %lu), %%rax\n", ASEXTERN(vecdecl)->val, WORDSIZE);
}

static void genstr(struct node *n)
{
    assert(n->type == N_STRING);

    fprintf(out, "\tmovq $str_%d, %%rax\n", n->id);

    appendstr(n->id, ((struct strnode *)n)->val);
}

static void genvardef(struct node *n)
{
    char buffer[128];

    assert(n->type == N_VARDEF);

    struct vardefnode *v = (struct vardefnode *)n;

    memset(buffer, 0, sizeof(buffer));

    if (v->init) {
        assert(v->init->type == N_INT);
        snprintf(buffer, sizeof(buffer), "%s: .quad %lld\n", 
                 ASNAME(v->name)->val, ASINT(v->init)->val);
    } else {
        snprintf(buffer, sizeof(buffer), "%s: .zero %lu\n", 
                 ASNAME(v->name)->val, WORDSIZE);
    }

    appenddata(buffer);
}

static void genvecdef(struct node *n)
{
    char buffer[128];

    assert(n->type == N_VECDEF);

    struct vecdefnode *v = (struct vecdefnode *)n;

    memset(buffer, 0, sizeof(buffer));

    assert(v->count->type == N_INT);
    snprintf(buffer, sizeof(buffer), "%s: .zero %lld\n",
             ASNAME(v->name)->val, ASINT(v->count)->val * WORDSIZE);
    
    appenddata(buffer);
}

static void genternary(struct node *n)
{
    assert(n->type == N_TERNARY);

    struct ternarynode *t = (struct ternarynode*)n;

    gen(t->cond);
    fprintf(out, "\tcmpq $0, %%rax\n");
    fprintf(out, "\tje tern_%d_false\n", t->id);
    gen(t->truee);
    fprintf(out, "\tjmp tern_%d_end\n", t->id);
    fprintf(out, "tern_%d_false:\n", t->id);
    gen(t->falsee);
    fprintf(out, "tern_%d_end:\n", t->id);
}

static void gen(struct node *n)
{
    assert(n);
    switch(n->type) {
    case N_EMPTY:
        /* do nothing */
        break;
    case N_EXTERN:
        fprintf(out, "\tmovq %s, %%rax\n", ASEXTERN(n)->val);
        break;
    case N_AUTO:
        fprintf(out, "\tmovq -%llu(%%rbp), %%rax\n", ASAUTO(n)->offset);
        break;
    case N_INT:
        fprintf(out, "\tmovq $%lld, %%rax\n", ASINT(n)->val);
        break;
    case N_STRING:
        genstr(n);
        break;
    case N_NAME:
        genname(n);
        break;
    case N_LIST:
        genlist(n);
        break;
    case N_CALL:
        gencall(n);
        break;
    case N_FUNDEF:
        genfundef(n);
        break;
    case N_ASSIGN:
        genassign(n);
        break;
    case N_BINARY:
        genbinary(n);
        break;
    case N_UNARY:
        genunary(n);
        break;
    case N_RETURN:
        genreturn(n);
        break;
    case N_IF:
        genif(n);
        break;
    case N_WHILE:
        genwhile(n);
        break;
    case N_VECELEM:
        genvecelem(n);
        break;
    case N_VARDEF:
        genvardef(n);
        break;
    case N_VECDEF:
        genvecdef(n);
        break;
    case N_TERNARY:
        genternary(n);
        break;
    default:
        assert(0);
    };
}

void codegen(struct node* root)
{
#ifdef DEBUG
    print(root, 0);
#endif

    fprintf(out, "\t.text\n");
    gen(root);

    fprintf(out, "\t.data\n");
    for (int i = 0; i < datactr; ++i) {
        fprintf(out, "%s", data[i]);
    }
}
