#include "codegen.h"
#include "helpers.h"

#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "b.tab.h"      /* generated by bison for the tokens */

extern FILE *out;    /* from main.c */

// TODO: dynarr
static const char *data[1024];
static int data_ctr;

static struct defnode *curr_def = NULL;

static void gen(struct node *n);

static char *argreg(int index)
{
    switch(index) {
    case 0: return "%rdi";
    case 1: return "%rsi";
    case 2: return "%rdx";
    case 3: return "%rcx";
    case 4: return "%r8";
    case 5: return "%r9";
    default:
        assert(0);
    }
}

static void gendecl(void)
{
    struct autonode *a;

    assert(curr_def);

    if (!curr_def->decls)
        return;

    struct listnode *curr = ASLIST(curr_def->decls);
    while (curr) {
        assert(curr->val->type == N_EXTERN || curr->val->type == N_AUTO);
        if (curr->val->type == N_AUTO) {
            a = ASAUTO(curr->val);
            curr_def->stacksize += WORD_SIZE;
            ASAUTO(curr->val)->offset = curr_def->stacksize;   /* update the list element, not the copy */
            fprintf(out, "\tsubq $%lu, %%rsp\n", WORD_SIZE);

            if (a->init) {
                assert(a->init->type == N_INT);
                fprintf(out, "\tmovq $%llu, -%llu(%%rbp)\n", ASINT(a->init)->val, curr_def->stacksize);
            }
        }
        curr = curr->next;
    }
}

static void genargs(struct node *n)
{
    struct autonode *a;

    assert(curr_def);

    if (!n)
        return;

    assert(n->type == N_LIST);
    struct listnode *curr = ASLIST(n);
    int i = 0;
    while (curr) {
        assert(curr->val->type == N_NAME);
        a = ASAUTO(mkauto(ASNAME(curr->val)->val));
        curr_def->stacksize += WORD_SIZE;
        a->offset = curr_def->stacksize;
        fprintf(out, "\tsubq $%lu, %%rsp\n", WORD_SIZE);
        fprintf(out, "\tmovq %s, -%llu(%%rbp)\n", argreg(i++), curr_def->stacksize);

        curr_def->decls = listback(curr_def->decls, ASNODE(a));

        curr = curr->next;
    }
}

static void gendef(struct node *n)
{
    assert(n->type == N_DEF);

    struct defnode *def = (struct defnode*)n;

    curr_def = def;

    assert(def->body);

    fprintf(out, "\t.global %s\n", ASSTR(def->name)->val);
    fprintf(out, "%s:\n", ASSTR(def->name)->val);

    // prolog
    fprintf(out, "\tpushq %%rbp\n");
    fprintf(out, "\tmovq %%rsp, %%rbp\n");

    gendecl();
    genargs(def->args);

    gen(def->body);

    // epilog
    fprintf(out, "end_%d:\n", curr_def->id);
    fprintf(out, "\taddq $%llu, %%rsp\n", curr_def->stacksize);

    fprintf(out, "\tpopq %%rbp\n");
    fprintf(out, "\tret\n");
    fprintf(out, "\n");

    curr_def = NULL;
}

static void genlist(struct node *n)
{
    if (!n)
        return;

    assert(n->type == N_LIST);
    struct listnode *curr = (struct listnode*)n;
    while (curr) {
        gen(curr->val);
        curr = curr->next;
    }
}

static void genbinary(struct node *n)
{
    assert(n);
    assert(n->type == N_BINARY);

    struct binarynode *b = (struct binarynode*)n;

    gen(b->right);  // value in %rax
    fprintf(out, "\tpushq %%rax\n");
    gen(b->left);   // value in %rax
    fprintf(out, "\tpopq %%rbx\n");
   
    switch(b->op) {
    case '+':
        fprintf(out, "\taddq %%rbx, %%rax\n");
        break;
    case '-':
        fprintf(out, "\tsubq %%rbx, %%rax\n");
        break;
    case '*':
        fprintf(out, "\timulq %%rbx, %%rax\n");
        break;
    case '/':
        fprintf(out, "\tmovq $0, %%rdx\n");
        fprintf(out, "\tcqto\n");
        fprintf(out, "\tidivq %%rbx\n");
        break;
    case '%':
        fprintf(out, "\tmovq $0, %%rdx\n");
        fprintf(out, "\tcqto\n");
        fprintf(out, "\tidivq %%rbx\n");
        fprintf(out, "\tmovq %%rdx, %%rax\n");
        break;
    case '<':
        fprintf(out, "\tcmp %%rbx, %%rax\n");
        fprintf(out, "\tjge ge_%d\n", n->id);
        fprintf(out, "\tmovq $1, %%rax\n");
        fprintf(out, "\tjmp end_%d\n", n->id);
        fprintf(out, "\tge_%d:\n", n->id);
        fprintf(out, "\tmovq $0, %%rax\n");
        fprintf(out, "\tend_%d:\n", n->id);
        break;
    case '>':
        fprintf(out, "\tcmp %%rbx, %%rax\n");
        fprintf(out, "\tjle le_%d\n", n->id);
        fprintf(out, "\tmovq $1, %%rax\n");
        fprintf(out, "\tjmp end_%d\n", n->id);
        fprintf(out, "\tle_%d:\n", n->id);
        fprintf(out, "\tmovq $0, %%rax\n");
        fprintf(out, "\tend_%d:\n", n->id);
        break;
    case LESSEQU:
        fprintf(out, "\tcmp %%rbx, %%rax\n");
        fprintf(out, "\tjle le_%d\n", n->id);
        fprintf(out, "\tmovq $0, %%rax\n");
        fprintf(out, "\tjmp end_%d\n", n->id);
        fprintf(out, "\tle_%d:\n", n->id);
        fprintf(out, "\tmovq $1, %%rax\n");
        fprintf(out, "\tend_%d:\n", n->id);
        break;
    case GREATEQU:
        fprintf(out, "\tcmp %%rbx, %%rax\n");
        fprintf(out, "\tjge ge_%d\n", n->id);
        fprintf(out, "\tmovq $0, %%rax\n");
        fprintf(out, "\tjmp end_%d\n", n->id);
        fprintf(out, "\tge_%d:\n", n->id);
        fprintf(out, "\tmovq $1, %%rax\n");
        fprintf(out, "\tend_%d:\n", n->id);
        break;
    case EQU:
        fprintf(out, "\tcmp %%rbx, %%rax\n");
        fprintf(out, "\tje e_%d\n", n->id);
        fprintf(out, "\tmovq $0, %%rax\n");
        fprintf(out, "\tjmp end_%d\n", n->id);
        fprintf(out, "\te_%d:\n", n->id);
        fprintf(out, "\tmovq $1, %%rax\n");
        fprintf(out, "\tend_%d:\n", n->id);
        break;
    case NOTEQU:
        fprintf(out, "\tcmp %%rbx, %%rax\n");
        fprintf(out, "\tjne ne_%d\n", n->id);
        fprintf(out, "\tmovq $0, %%rax\n");
        fprintf(out, "\tjmp end_%d\n", n->id);
        fprintf(out, "\tne_%d:\n", n->id);
        fprintf(out, "\tmovq $1, %%rax\n");
        fprintf(out, "\tend_%d:\n", n->id);
        break;
    default:
        assert(0);
    }
}

static void gencall(struct node *n)
{
    int argindex; 
    assert(n);
    assert(n->type == N_CALL);

    char buffer[128];

    struct callnode *call = (struct callnode*)n;

    if (call->args)
    {
        struct listnode *args = (struct listnode*)call->args;
        argindex = 0;
        while (args) {
            struct node *arg = args->val;

            if (arg->type == N_STRING) {
                fprintf(out, "\tmovq $str_%d, %s\n", arg->id, argreg(argindex));
                memset(buffer, 0, sizeof(buffer));
                snprintf(buffer, sizeof(buffer), "str_%d: .ascii \"%s\"\n", arg->id, ASSTR(arg)->val);
                data[data_ctr++] = strdup(buffer);
            } else if (arg->type == N_INT) {
                fprintf(out, "\tmovq $%llu, %s\n", ASINT(arg)->val, argreg(argindex));
            } else if (arg->type == N_NAME) {
                struct node *d = finddecl(curr_def->decls, ASNODE(arg));
                assert(d);
                assert(d->type == N_AUTO);
                fprintf(out, "\tmovq -%llu(%%rbp), %s\n", ASAUTO(d)->offset, argreg(argindex));
            } else if (arg->type == N_BINARY) {
                genbinary(arg);
                fprintf(out, "\tmovq %%rax, %s\n", argreg(argindex));
            } else if (arg->type == N_CALL) {
                gencall(arg);
                fprintf(out, "\tmovq %%rax, %s\n", argreg(argindex));
            } else {
                assert(0);
            }

            args = args->next;
            argindex++;
        }
    }

    fprintf(out, "\tcall %s\n", ((struct namenode *)call->name)->val);
}

static void genname(struct node *n)
{
    assert(n);
    assert(n->type == N_NAME);

    struct node *var = finddecl(curr_def->decls, n);
    assert(var);

    assert(var->type == N_AUTO || var->type == N_EXTERN);
    gen(var);
}

static void genassign(struct node *n)
{
    assert(n);
    assert(n->type == N_ASSIGN);

    struct assignnode *a = (struct assignnode *)n;

    assert(a->left);
    assert(a->left->type == N_NAME);
    assert(a->right);

    struct node *left = finddecl(curr_def->decls, a->left);
    assert(left);

    if (a->right->type == N_INT)
        fprintf(out, "\tmovq $%lld, %%rax\n", ASINT(a->right)->val);
    else if (a->right->type == N_BINARY)
        genbinary(a->right);
    else if (a->right->type == N_CALL)
        gencall(a->right);
    else
        assert(0);

    if (left->type == N_AUTO)
        fprintf(out, "\tmovq %%rax, -%llu(%%rbp)\n", ASAUTO(left)->offset);
    else if (left->type == N_EXTERN)
        fprintf(out, "\tmovq %%rax, %s\n", ASEXTERN(left)->val);
    else
        assert(0);
}

static void genreturn(struct node *n)
{
    assert(n);
    assert(n->type == N_RETURN);

    assert(curr_def);

    struct returnnode *ret = (struct returnnode *)n;

    if (ret->val)
        gen(ret->val);

    fprintf(out, "\tjmp end_%d\n", curr_def->id);
}

static void genif(struct node *n)
{
    assert(n);
    assert(n->type == N_IF);

    struct ifnode *iff = (struct ifnode *)n;

    assert(iff->cond);
    assert(iff->truee);

    gen(iff->cond);
    fprintf(out, "\tcmpq $0, %%rax\n");
    if (iff->falsee) {
        fprintf(out, "\tje if_%d_false\n", iff->id);
        gen(iff->truee);
        fprintf(out, "\tjmp if_%d_end\n", iff->id);
        fprintf(out, "if_%d_false:\n", iff->id);
        gen(iff->falsee);
        fprintf(out, "if_%d_end:\n", iff->id);
    } else {
        fprintf(out, "\tje if_%d_end\n", iff->id);
        gen(iff->truee);
        fprintf(out, "if_%d_end:\n", iff->id);
    }
}

static void genwhile(struct node *n)
{
    assert(n);
    assert(n->type == N_WHILE);

    struct whilenode *w = (struct whilenode *)n;

    assert(w->cond);
    assert(w->body);

    fprintf(out, "while_%d_start:\n", w->id);
    gen(w->cond);
    fprintf(out, "\tcmpq $0, %%rax\n");
    fprintf(out, "\tje while_%d_end\n", w->id);
    gen(w->body);
    fprintf(out, "\tjmp while_%d_start\n", w->id);
    fprintf(out, "while_%d_end:\n", w->id);
}

static void gen(struct node *n)
{
    assert(n);
    switch(n->type) {
    case N_EMPTY:
        /* do nothing */
        break;
    case N_EXTERN:
        fprintf(out, "\tmovq %s, %%rax\n", ASEXTERN(n)->val);
        break;
    case N_AUTO:
        fprintf(out, "\tmovq -%llu(%%rbp), %%rax\n", ASAUTO(n)->offset);
        break;
    case N_INT:
        fprintf(out, "\tmovq $%lld, %%rax\n", ASINT(n)->val);
        break;
    case N_STRING:
        fprintf(out, "\tmovq $str_%d, %%rax\n", n->id);
        break;
    case N_NAME:
        genname(n);
        break;
    case N_LIST:
        genlist(n);
        break;
    case N_CALL:
        gencall(n);
        break;
    case N_DEF:
        gendef(n);
        break;
    case N_ASSIGN:
        genassign(n);
        break;
    case N_BINARY:
        genbinary(n);
        break;
    case N_RETURN:
        genreturn(n);
        break;
    case N_IF:
        genif(n);
        break;
    case N_WHILE:
        genwhile(n);
        break;
    default:
        assert(0);
    };
}

void codegen(struct node* root)
{
#ifdef DEBUG
    print(root, 0);
#endif

    fprintf(out, "\t.text\n");
    gen(root);

    fprintf(out, "\t.data\n");
    for (int i = 0; i < data_ctr; ++i) {
        fprintf(out, "%s", data[i]);
    }
}
