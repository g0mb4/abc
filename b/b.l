%{  /* user defined code needed for the rules */

#include <stdlib.h>
#include "b.tab.h"      /* generated by bison for the return values */
#include "ast.h"        /* for "word" */

extern void yyerror(const char * s, ...);
char *strdupquotes(const char * s);

int escape(char c);

word strtoword(const char *s);

%} /* end of the user defined code */

/* use line numbers */
%option yylineno
/* don't generate input() */
%option noinput
/* don't generate yyunput() */
%option nounput

ALPHA   [A-Za-z_]
DIGIT   [0-9]

NAME    {ALPHA}+
NUM     {DIGIT}+

%x COMMENT

%%  /* start of the rules */

"/*"                    { BEGIN(COMMENT); }
<COMMENT>"*/"           { BEGIN(INITIAL); }
<COMMENT>.              { }

\"(\\.|[^"\\])*\"       { yylval.s = strdupquotes(yytext); return str; }
{NUM}                   { yylval.w = strtoword(yytext); return number; }

"auto"          { return autoo; }
"extrn"         { return extrn; }
 /* "if"            { return T_IF; } */
 /* "while"         { return T_WHILE; } */
 /* "switch"        { return T_SWITCH; } */
 /* "case"          { return T_CASE; } */
 /* "goto"          { return T_GOTO; } */
 /* "return"        { return T_RETURN; } */

{NAME}          { yylval.s = strdup(yytext); return name; }
\(              { return '('; }
\)              { return ')'; }
\{              { return '{'; }
\}              { return '}'; }

;               { return ';'; }
,               { return ','; }

=               { return '='; }

\n              { } /* update yylineno */
[ \t\r]+        { ; } /* ignore whitespace */
.               { yyerror("unrecognized input: %s", yytext); }
%%  /* end of the rules */

/* for the compiler */
int yywrap(void)
{
    return 1;
}

word strtoword(const char *s)
{
    if (*s == '0')
        return strtoull(s, NULL, 8);
    else
        return strtoull(s, NULL, 10);
}

int escape(char c)
{
    switch (c) {
    case '0':
    case 't':
    case '*':
    case '\'':
    case '"':
    case 'n':
        return c;
    case '(':
        return '{';
    case ')':
        return '}';
    case 'e':
        return '0';
    default:
        return -1;
    }
}

char *strdupquotes(const char * s)
{
    int i, j = 0, len;
    char *dest;
    int esc;

    len = strlen(s);

    if (len <= 2){
        yyerror("invalid string literal: %s", s);
        return NULL;
    }

    dest = malloc(len - 1);   /* lenght - 2 quotes + 1 terminator */
    if (!dest) {
        yyerror("unable to create string literal");
        return NULL;
    }

    for (i = 1; i < (len - 1); i++){
        if (s[i] == '*') {
            esc = escape(s[i+1]);
            if (esc > 0) {
                i++;
                dest[j++] = '\\';
                dest[j++] = (char)esc;
            } else {
                yyerror("invalid escape sequence in: %s", s);
            }
        } else {
            dest[j++] = s[i];
        }
    }

    dest[j] = '\0';

    return dest;
}
