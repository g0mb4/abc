%{  /* user defined code needed for the rules */

#include <stdlib.h>
#include "b.tab.h"      /* generated by bison for the tokens */
#include "ast.h"        /* for "word" */

extern void yyerror(const char * s, ...);
char *strdupquotes(const char * s);

int escape(char c);

word strtoword(const char *s);
word strtochar(const char *s);

%} /* end of the user defined code */

/* use line numbers */
%option yylineno
/* don't generate input() */
%option noinput
/* don't generate yyunput() */
%option nounput

%x COMMENT

%%  /* start of the rules */

"/*"                    { BEGIN(COMMENT); }
<COMMENT>"*/"           { BEGIN(INITIAL); }
<COMMENT>\n             { yylineno++; }
<COMMENT>.              { }

\"(\\.|[^"\\])*\"           { yylval.s = strdupquotes(yytext); return STR; }
[\'][A-Za-z0-9_*()']+[\']   { yylval.w = strtochar(yytext); return INT; }
[0-9]+                      { yylval.w = strtoword(yytext); return INT; }

"auto"              { return AUTO; }
"extrn"             { return EXTRN; }
"if"                { return IF; }
"else"              { return ELSE; }
"while"             { return WHILE; }
 /* "switch"        { return T_SWITCH; } */
 /* "case"          { return T_CASE; } */
 /* "goto"          { return T_GOTO; } */
"return"            { return RETURN; }

[A-Za-z_]+      { yylval.s = strdup(yytext); return NAME; }

"<="            { yylval.w = LESSEQU; return LESSEQU; }
">="            { yylval.w = GREATEQU; return GREATEQU; }
"=="            { yylval.w = EQU; return EQU; }
"!="            { yylval.w = NOTEQU; return NOTEQU; }

"++"            { yylval.w = INC; return INC; }
"--"            { yylval.w = DEC; return DEC; }

"("             { return '('; }
")"             { return ')'; }
"{"             { return '{'; }
"}"             { return '}'; }

";"             { return ';'; }
","             { return ','; }

"+"             { yylval.w = '+'; return '+'; }
"-"             { yylval.w = '-'; return '-'; }
"*"             { yylval.w = '*'; return '*'; }
"/"             { yylval.w = '/'; return '/'; }
"%"             { yylval.w = '%'; return '%'; }

"&"             { yylval.w = '&'; return '&'; }
"|"             { yylval.w = '|'; return '|'; }
"!"             { yylval.w = '!'; return '!'; }

"<"             { yylval.w = '<'; return '<'; }
">"             { yylval.w = '>'; return '>'; }

"="             { return '='; }

\n              { } /* update yylineno */
[ \t\r]+        { ; } /* ignore whitespace */
.               { yyerror("unrecognized input: %s", yytext); }
%%  /* end of the rules */

/* for the compiler */
int yywrap(void)
{
    return 1;
}

word strtoword(const char *s)
{
    if (*s == '0')
        return strtoll(s, NULL, 8);
    else
        return strtoll(s, NULL, 10);
}

int escape(char c)
{
    switch (c) {
    case '0':
    case 't':
    case '*':
    case '\'':
    case '"':
    case 'n':
        return c;
    case '(':
        return '{';
    case ')':
        return '}';
    case 'e':
        return '0';
    default:
        return -1;
    }
}

int escapeval(char c)
{
    switch (c) {
    case '0':
        return '\0';
    case 't':
        return '\t';
    case 'n':
        return '\n';
    case '(':
        return '{';
    case ')':
        return '}';
    case 'e':
        return '\0';
    case '*':
    case '\'':
    case '"':
        return c;
    default:
        return -1;
    }
}

char *strdupquotes(const char * s)
{
    int i, j = 0, len;
    char *dest;
    int esc;

    len = strlen(s);

    if (len <= 2){
        yyerror("invalid string literal: %s", s);
        return NULL;
    }

    dest = malloc(len - 1);   /* lenght - 2 quotes + 1 terminator */
    if (!dest) {
        yyerror("unable to create string literal");
        return NULL;
    }

    for (i = 1; i < (len - 1); i++){
        if (s[i] == '*') {
            esc = escape(s[i+1]);
            if (esc > 0) {
                i++;
                dest[j++] = '\\';
                dest[j++] = (char)esc;
            } else {
                yyerror("invalid escape sequence in: %s", s);
            }
        } else {
            dest[j++] = s[i];
        }
    }

    dest[j] = '\0';

    return dest;
}

word strtochar(const char *s)
{
    int i, j, len, esc;
    word w = 0;

    len = strlen(s);
    if (len <= 2 || len > (int)WORD_SIZE * 2){
        yyerror("invalid character literal: %s", s);
        return -1;
    }

    for (i = 1, j = 0; i < len-1; ++i, ++j) {
        if (s[i] == '*') {
            esc = escapeval(s[i+1]);
            if (esc > 0) {
                w |= ((char)esc << (j * 8));
                i++;
            } else {
                yyerror("invalid escape sequence in: %s", s);
            }
        } else {
            w |= (s[i] << (j * 8));
        }
    }

    return w;
}
