%{  /* user defined code needed for the rules */

#include <stdlib.h>
#include "b.tab.h"      /* generated by bison for the return values */
#include "ast.h"        /* for "word" */

extern void yyerror(const char * s, ...);
char *strdupquotes(const char * s);

int escape(char c);

word strtoword(const char *s);
word strtochar(const char *s);

%} /* end of the user defined code */

/* use line numbers */
%option yylineno
/* don't generate input() */
%option noinput
/* don't generate yyunput() */
%option nounput

%x COMMENT

%%  /* start of the rules */

"/*"                    { BEGIN(COMMENT); }
<COMMENT>"*/"           { BEGIN(INITIAL); }
<COMMENT>\n             { yylineno++; }
<COMMENT>.              { }

\"(\\.|[^"\\])*\"           { yylval.s = strdupquotes(yytext); return str; }
[\'][A-Za-z0-9_*()']+[\']   { yylval.w = strtochar(yytext); return number; }
[0-9]+                      { yylval.w = strtoword(yytext); return number; }

"auto"              { return autoo; }
"extrn"             { return extrn; }
"if"                { return iff; }
"else"              { return elsee; }
"while"             { return whilee; }
 /* "switch"        { return T_SWITCH; } */
 /* "case"          { return T_CASE; } */
 /* "goto"          { return T_GOTO; } */
"return"            { return returnn; }

[A-Za-z_]+      { yylval.s = strdup(yytext); return name; }
\(              { return '('; }
\)              { return ')'; }
\{              { return '{'; }
\}              { return '}'; }

;               { return ';'; }
,               { return ','; }

\+              { yylval.w = '+'; return '+'; }
\-              { yylval.w = '-'; return '-'; }
\*              { yylval.w = '*'; return '*'; }
\/              { yylval.w = '/'; return '/'; }
\%              { yylval.w = '%'; return '%'; }

=               { return '='; }

\n              { } /* update yylineno */
[ \t\r]+        { ; } /* ignore whitespace */
.               { yyerror("unrecognized input: %s", yytext); }
%%  /* end of the rules */

/* for the compiler */
int yywrap(void)
{
    return 1;
}

word strtoword(const char *s)
{
    if (*s == '0')
        return strtoll(s, NULL, 8);
    else
        return strtoll(s, NULL, 10);
}

int escape(char c)
{
    switch (c) {
    case '0':
    case 't':
    case '*':
    case '\'':
    case '"':
    case 'n':
        return c;
    case '(':
        return '{';
    case ')':
        return '}';
    case 'e':
        return '0';
    default:
        return -1;
    }
}

int escapeval(char c)
{
    switch (c) {
    case '0':
        return '\0';
    case 't':
        return '\t';
    case 'n':
        return '\n';
    case '(':
        return '{';
    case ')':
        return '}';
    case 'e':
        return '\0';
    case '*':
    case '\'':
    case '"':
        return c;
    default:
        return -1;
    }
}

char *strdupquotes(const char * s)
{
    int i, j = 0, len;
    char *dest;
    int esc;

    len = strlen(s);

    if (len <= 2){
        yyerror("invalid string literal: %s", s);
        return NULL;
    }

    dest = malloc(len - 1);   /* lenght - 2 quotes + 1 terminator */
    if (!dest) {
        yyerror("unable to create string literal");
        return NULL;
    }

    for (i = 1; i < (len - 1); i++){
        if (s[i] == '*') {
            esc = escape(s[i+1]);
            if (esc > 0) {
                i++;
                dest[j++] = '\\';
                dest[j++] = (char)esc;
            } else {
                yyerror("invalid escape sequence in: %s", s);
            }
        } else {
            dest[j++] = s[i];
        }
    }

    dest[j] = '\0';

    return dest;
}

word strtochar(const char *s)
{
    int i, j, len, esc;
    word w = 0;

    len = strlen(s);
    if (len <= 2 || len > WORD_SIZE * 2){
        yyerror("invalid character literal: %s", s);
        return -1;
    }

    for (i = 1, j = 0; i < len-1; ++i, ++j) {
        if (s[i] == '*') {
            esc = escapeval(s[i+1]);
            if (esc > 0) {
                w |= ((char)esc << (j * 8));
                i++;
            } else {
                yyerror("invalid escape sequence in: %s", s);
            }
        } else {
            w |= (s[i] << (j * 8));
        }
    }

    return w;
}